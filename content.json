[{"title":"Mac 使用 tree 生成目录结构","date":"2017-11-13T08:21:32.000Z","path":"posts/2017/mac-usage-tree/","text":"写文章时，经常需要将一个目录的结构列出来。或许可以直接截图贴上来，但有时图片并不能体现出完整的结构。下面，将使用 tree 来实现这种效果。 . ├── README.md ├── _config.yml ├── package-lock.json ├── package.json ├── scaffolds │ ├── draft.md │ ├── page.md │ └── post.md ├── source │ ├── 404.html │ ├── CNAME │ ├── _posts │ ├── categories │ ├── plugins │ └── tags └── themes ├── indigo └── landscape tree 安装macOS 下直接使用 Homebrew 安装。 $ brew install tree tree 常用命令# 打印当前目录下的所有文件 $ tree $ tree -a # 只打印目录 $ tree -d # 限制追溯的目录层级。n 表示层级数 $ tree -L n # 只列出与给定模式匹配的文件，pattern 可以是正则表达式 $ tree -P pattern # eg: tree -P &#39;*.jpg&#39; # 不列出与给定模式匹配的文件，pattern 可以是正则表达式 $ tree -I pattern # eg: tree -I &#39;node_modules&#39; # 模式匹配时忽略大小写 $ tree -I pattern --ignore-case # eg: tree -I &#39;*.JPG&#39; --ignore-case # 复合写法：不列出 node_modules 目录，且限制追溯层级为 3 $ tree -L 3 -I &quot;node_modules&quot; # 不要追溯到文件数超过 # 的目录中 $ tree --filelimit # # eg: tree --filelimit 7 # 输出到文件而不是标准输出流 $ tree -o filename # eg: tree -o tree.html $ tree &gt; filename # eg: tree &gt; tree.html # 按原样打印不可打印的字符，默认情况下中文会被显示为一串转义字符，使用 -N 可以显示出中文 $ tree -N # 打印 dir 目录下的所有文件，以及权限 $ tree -p &lt;dir&gt; # eg: tree -p img # 打印每个文件的字节大小 $ tree -s # 打印 dir 目录下的所有文件，以及人类通俗易懂的大小 $ tree -h &lt;dir&gt; # 选择排序：name，version，size，mtime，ctime $ tree --sort=size # 总是打开彩色显示。在文件和目录清单上加色彩，便于区分各种类型 $ tree -C # 以 baseHREF 为顶部目录打印 HTML 格式 $ tree -H baseHREF # eg: tree -H . -o tree.html # 用 string 替换默认的 HTML 标题和 H1 标题 $ tree -T string # eg: tree -T &#39;树结构&#39; -H . -o tree.html # 关闭 HTML 输出中的超链接 $ tree --nolinks # eg: tree --nolinks -H . -o tree.html 解读 tree –help$ tree --help usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ] [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;] [--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;] ------- Listing options ------- -a # All files are listed. # 列出所有文件。 -d # List directories only. # 只列出目录。 -l # Follow symbolic links like directories. # 遵循像目录一样的符号链接。 -f # Print the full path prefix for each file. # 在每个文件的前面打印完整的相对路径。 -x # Stay on current filesystem only. # 只停留在当前文件系统。若指定目录下的某些子目录存在另一个文件系统上，则排除该子目录。 -L level # Descend only level directories deep. # 只追溯到目录的 level 级。 -R # Rerun tree when max dir level reached. # 当达到最大目录层级时重新运行树。 -P pattern # List only those files that match the pattern given. # 只列出与给定模式匹配的文件。 -I pattern # Do not list files that match the given pattern. # 不列出与给定模式匹配的文件。 --ignore-case # Ignore case when pattern matching. # 模式匹配时忽略大小写。 --matchdirs # Include directory names in -P pattern matching. # 在 -P 模式匹配中包含目录名。 --noreport # Turn off file/directory count at end of tree listing. # 在树列表的末尾关闭文件/目录计数。 --charset X # Use charset X for terminal/HTML and indentation line output. # 为终端/HTML和压痕线输出指定字符集 X。 --filelimit # # Do not descend dirs with more than # files in them. # 不要追溯到文件数超过 # 的目录中。 --timefmt &lt;f&gt; # Print and format time according to the format &lt;f&gt;. # 根据格式 &lt;f&gt; 打印和格式化时间。 -o filename # Output to file instead of stdout. # 输出到文件而不是标准输出流。 -------- File options --------- -q # Print non-printable characters as &#39;?&#39;. # 打印不可打印的字符为 &#39;?&#39;。 -N # Print non-printable characters as is. # 按原样打印不可打印的字符。 -Q # Quote filenames with double quotes. # 用双引号引用文件名。 -p # Print the protections for each file. # 打印每个文件的权限。 -u # Displays file owner or UID number. # 显示文件所有者或者 UID 号。 -g # Displays file group owner or GID number. # 显示文件组所有者或者 GID 号。 -s # Print the size in bytes of each file. # 打印每个文件的字节大小。 -h # Print the size in a more human readable way. # 以人类通俗易懂的方式打印文件的大小。 --si # Like -h, but use in SI units (powers of 1000). # 类似 -h，但使用的是 SI 单位（1000 的幂）。 -D # Print the date of last modification or (-c) status change. # 打印最后修改或者（-c）状态更改的日期。 -F # Appends &#39;/&#39;, &#39;=&#39;, &#39;*&#39;, &#39;@&#39;, &#39;|&#39; or &#39;&gt;&#39; as per ls -F. # 附加 &#39;/&#39;，&#39;=&#39;，&#39;*&#39;，&#39;@&#39;，&#39;|&#39; 或 &#39;&gt;&#39;，如 ls -F。 --inodes # Print inode number of each file. # 打印每个文件的 inode 号。 --device # Print device ID number to which each file belongs. # 打印每个文件所属的设备 ID 号。 ------- Sorting options ------- -v # Sort files alphanumerically by version. # 按字母数字排序文件。 -t # Sort files by last modification time. # 按最后修改时间排序文件。 -c # Sort files by last status change time. # 按最后状态改变时间排序文件。 -U # Leave files unsorted. # 把文件分类。 -r # Reverse the order of the sort. # 倒序排序。 --dirsfirst # List directories before files (-U disables). # 在列出文件之前先列出目录（-U 无效）。 --sort X # Select sort: name,version,size,mtime,ctime. # 选择排序：name，version，size，mtime，ctime。 ------- Graphics options ------ -i # Don&#39;t print indentation lines. # 不打印压痕线。不以阶梯状列出文件或目录名称。 -A # Print ANSI lines graphic indentation lines. # 打印 ANSI 线图形压痕线。使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。 -S # Print with CP437 (console) graphics indentation lines. # 打印带有 CP437（控制台）图像压痕线。 -n # Turn colorization off always (-C overrides). # 总是关闭彩色显示（-C 覆盖）。 -C # Turn colorization on always. # 总是打开彩色显示。在文件和目录清单上加色彩，便于区分各种类型。 ------- XML/HTML/JSON options ------- -X # Prints out an XML representation of the tree. # 打印出树的 XML 表示。 -J # Prints out an JSON representation of the tree. # 打印出树的 JSON 表示。 -H baseHREF # Prints out HTML format with baseHREF as top directory. # 以 baseHREF 为顶部目录打印 HTML 格式。 -T string # Replace the default HTML title and H1 header with string. # 用 string 替换默认的 HTML 标题和 H1 标题。 --nolinks # Turn off hyperlinks in HTML output. # 关闭 HTML 输出中的超链接。 ---- Miscellaneous options ---- --version # Print version and exit. # 打印版本号后退出。 --help # Print usage and this help message and exit. # 打印用法和帮助信息后退出。 -- # Options processing terminator. # 选项处理终结者。 参考 Liunx系统命令中tree命令详解 一天一个shell命令 linux文本操作系列-tree命令详解","tags":[{"name":"Mac","slug":"Mac","permalink":"https://mingfengst.github.io/tags/Mac/"}]},{"title":"Homebrew 的用法","date":"2017-11-11T02:26:45.000Z","path":"posts/2017/mac-usage-homebrew/","text":"Homebrew 是 macOS 系统中最受欢迎的包管理工具，以最简单、最灵活的方式来安装苹果公司在 macOS 中不包含的 UNIX 工具。 Homebrew 官网Homebrew 文档 Homebrew 安装安装 Homebrew 之前，需要先安装 Xcode Command Line Tools Homebrew 的安装很简单，只要打开终端执行以下命令。 $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 终端会让用户确认是否继续安装所列出来的脚本。按 RETURN 键继续，之后可能需要输入用户密码，就可以安装完成了。 Press RETURN to continue or any other key to abort 检查是否安装成功，能获取到对应版本号，则说明安装成功。 $ brew -v 卸载 $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; Homebrew 常用命令# 安装软件 $ brew install formula # 卸载软件 $ brew uninstall formula # 搜索软件 $ brew search formula # 更新软件 $ brew upgrade formula # 查看安装列表 $ brew list # 更新 Homebrew $ brew update","tags":[{"name":"Mac","slug":"Mac","permalink":"https://mingfengst.github.io/tags/Mac/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://mingfengst.github.io/tags/Homebrew/"}]},{"title":"命名规则","date":"2014-07-01T05:24:58.000Z","path":"posts/2014/naming-rule/","text":"前言规范的命名在程序开发中有明显的优势，它即能让自己日后维护简单，也能让团队友好的合作，在网页开发中，特别是团队合作，命名是非常重要的。 页面命名页面结构# 外围 wrapper # 主体 main # 内容 content | container # 页头 header # 页脚 | 页尾 footer # 中 middle | center # 上 top # 下 bottom # 左 left # 右 right 页面分区# 菜单 menu # 子菜单 submenu # 标题 title # 标志 logo # 图标 icon # 导航 nav # 主导航 mainbav # 子导航 subnav # 顶导航 topnav # 边导航 | 侧栏 sidebar # 栏目 | 纵栏 column # 左导航 leftsidebar # 右导航 rightsidebar # 标签页 tab # 登录条 loginbar # 购物车 shop # 广告 banner # 热点 hot # 新闻 news # 摘要 summary # 文章列表 list # 状态 status # 提示信息 msg # 小技巧 tips # 指南 guide # 服务 service # 加入 joinus # 版权 copyright # 友情链接 friendlink | link # 合作伙伴 partner 功能# 登录 login | log # 注册 regsiter | reg # 下载 download # 搜索 search # 滚动 scroll # 投票 vote # 当前的 current # 注释 note 组件# 按钮 btn # 输入框 ipt 样式命名颜色使用颜色的名称或者 16 进制代码。 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字号直接使用 “font + 字体大小”。 .font12px { font-size: 12px; } .font9pt { font-size: 9pt; } 对齐使用对齐目标的英文名称。 .left { float: left; } .bottom { float: bottom; } 标题使用 “类别+功能” 的方式。 .barnews { } .barproduct { } 文件命名 一律小写。 尽量用英文。 不加中杆和下划线。 尽量不缩写，除非一看就明白的单词。 # 主要的 master.css # 模块 module.css # 基本共用 base.css # 主题 themes.css # 专栏 columns.css # 打印 print.css # 文字 font.css # 表单 forms.css # 补丁 mend.css # 布局 | 版面 layout.css 注释写法/* Footer */ 内容区 /* End Footer */","tags":[{"name":"规范","slug":"规范","permalink":"https://mingfengst.github.io/tags/规范/"}]},{"title":"修改博客代码块的语法高亮风格","date":"2014-06-19T06:07:42.000Z","path":"posts/2014/blog-code-highlight/","text":"刚用 Hexo+GitHub 搭建个人博客并更换 indigo 主题后，由于个人对里面代码块的语法高亮风格并不喜欢，就自己尝试着更换风格。这里以我使用的 indigo 主题 为例，总结出以下几种方式。 直接修改配色方案如果只是不喜欢代码块的语法高亮配色方案，那么直接修改项目中的 highlight.less 文件即可。可以参考这里的 配色方案。 修改 blog/themes/indigo/source/css/_partial/highlight.less 的配色方案或样式。 // Tomorrow Night Bright @h-background: #000000; @h-current-line: #2a2a2a; @h-selectioon: #424242; @h-foreground: #eaeaea; @h-comment: #969896; @h-red: #d54e53; @h-orange: #e78c45; @h-yellow: #e7c547; @h-green: #b9ca4a; @h-aqua: #70c0b1; @h-blue: #7aa6da; @h-purple: #c397d8; 修改 blog/_config.yml 的配置，将 highlight.enable 的值设置为 true。 # 代码块的设置 highlight: enable: true 如果你对样式也要做些改动，那么可以修改 blog/themes/indigo/layout/_partial/head.ejs 的模板。 &lt;!-- 主题默认的代码语法高亮风格：修改样式 --&gt; &lt;% if (config.highlight.enable) { %&gt; &lt;style&gt; .post-content .highlight { padding: 0.8em; margin-left: 0; margin-right: 0; border-radius: 5px; } .post-content .highlight pre { background: transparent; } /* 滚动条轨道 */ ::-webkit-scrollbar-track { border-radius: 5px; } &lt;/style&gt; &lt;% } %&gt; &lt;!-- 建议在文件中找到下面这句代码，在此前面进行修改 --&gt; &lt;script&gt;window.lazyScripts=[]&lt;/script&gt; 引入 highlight.js引入 highlight.js 实现代码的语法高亮，使用起来比较灵活，可以 预览 不同的语法高亮风格，也可以根据你需要实现高亮的语言 自定义 highlight.js 并下载，使 highlight.js 更轻量，更多用法可以查看 这里。 以 monokai-sublime 风格为例。将下载完的 highlight.zip 进行解压，并将 monokai-sublime.css 和 highlight.pack.js 文件拷贝到 blog/source/plugins/highlight 目录下。 修改 blog/_config.yml 的配置，跳过 plugins 目录下所有文件的渲染。 # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径 ## glob 表达式：https://github.com/isaacs/node-glob skip_render: - &#39;plugins/**&#39; 修改 blog/_config.yml 的配置，将 highlight.enable 的值设置为 false，并配置引入文件的路径。 # 代码块的设置 highlight: enable: false # 引入 highlight.js，自定义代码语法高亮风格 hl_custom: # css 路径 css_path: plugins/highlight/monokai-sublime.css # js 路径 js_path: plugins/highlight/highlight.pack.js 修改 blog/themes/indigo/layout/_partial/head.ejs 的模板。引入 css 和 js 文件，并对部分样式进行修改。 &lt;!-- 建议在文件中找到下面这句代码，在此后面进行修改 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(theme_css(&#39;/css/style&#39;, cache)) %&gt;&quot;&gt; &lt;!-- 自定义的代码语法高亮风格：引入 highlight.js --&gt; &lt;% if (!config.highlight.enable) { %&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(config.highlight.hl_custom.css_path) %&gt;&quot;&gt; &lt;script src=&quot;&lt;%- url_for(config.highlight.hl_custom.js_path) %&gt;&quot;&gt;&lt;/script&gt; &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; &lt;script&gt; Array.prototype.slice.call(document.querySelectorAll(&#39;pre code&#39;)).forEach(function(block) { hljs.highlightBlock(block); }) &lt;/script&gt; &lt;style&gt; .post-content pre { padding: 0; margin-left: 0; margin-right: 0; border-radius: 5px; } &lt;/style&gt; &lt;% } %&gt; 修改过程中保留了原来的样式表，样式表的优先级对引入 highlight.js 后的语法高亮效果和样式产生了影响，因此可以在 monokai-sublime.css 中将被影响的属性加上 !important，让其优先级最高。要是不确定哪个属性被影响了，可以给全部属性加上 !important。 通过对项目的修改，highlight.enable 的值与之前表示的有所不同： true：使用主题默认的高亮风格 false：使用 highlight.js 自定义的高亮风格 因此，我们可以通过修改 highlight.enable 的值，快速地切换主题默认的代码语法高亮风格和自定义的代码语法高亮风格。 参考 Hexo高级教程之代码高亮","tags":[{"name":"Blog","slug":"Blog","permalink":"https://mingfengst.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://mingfengst.github.io/tags/Hexo/"}]},{"title":"Hexo+GitHub 搭建个人博客","date":"2014-06-18T07:46:17.000Z","path":"posts/2014/blog-base-on-hexo-and-github/","text":"前言Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文是一篇基于 GitHub Pages 的 Hexo 博客搭建教程。 准备环境准备安装 Hexo 相当简单。然而在安装前，先检查电脑中是否已安装下列应用程序： Git Node.js 安装方法：参考文章 Git 的用法、Node 的用法。 检查方法：打开终端，依次输入以下命令，能获取到对应版本号，则说明安装成功。 # 查看 node 的版本号 node -v # 查看 npm 的版本号 npm -v # 查看 git 的版本号 git --version 如果电脑中已具备以上条件，那么只需要使用 npm 即可完成 Hexo 的全局安装。如有权限问题，使用 sudo 安装。 $ npm install -g hexo-cli $ sudo npm install -g hexo-cli 检查是否安装成功，能获取到对应版本号，则说明安装成功。 $ hexo -v 创建 blog 仓库登录 GitHub 账号，点击页面右上角的 +，选择 New repository。 博客仓库名必须是：username.github.io。比如我的博客仓库名是：mingfengst.github.io。 Jietu20180312-164955 开启 gh-pages点击界面右侧的 Settings，将会打开这个库的 setting 页面，向下拖动，直到看见 GitHub Pages，点击 Automatic page generator，GitHub 将会自动替你创建出一个 gh-pages 的页面。如果配置没问题的话，username.github.io 这个网址就可以正常访问了。 Jietu20180312-165843 创建 blog 项目初始化 hexo 项目，文件名以 blog 为例。 $ hexo init blog 进入 blog 目录 $ cd blog 安装依赖 $ npm install 生成静态页面 $ hexo generate 本地启动测试 $ hexo server INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. Jietu20180312-211146 打开浏览器，地址栏中输入：http://localhost:4000/ ，即可看见刚刚创建的博客了。 部署 blog 项目安装 hexo-deployer-git。 $ npm install hexo-deployer-git --save 修改 _config.yml 配置文件。 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git # 库（Repository）地址 repo: git@github.com:mingfengst/mingfengst.github.io.git # 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。 branch: master # 自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}) message: 注意： type: git 中的冒号后面有空格。 将 repo 替换成自己的 repository。 部署。 $ hexo deploy 打开浏览器，在地址栏输入 https://username.github.io 即可访问托管在 GitHub 上的博客。如我的博客地址是：https://mingfengst.github.io 。 更改 blog 配置https://hexo.io/zh-cn/docs/configuration.html 更换 blog 主题可以在这里选择自己喜欢的主题。 以 hexo-theme-indigo 为例。 安装主题要求：Hexo 版本在 3.0 以上，Node 版本为 6.x 以上。 进入 blog 目录，下载主题。 $ git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题进入 themes/indigo 目录。 $ cd themes/indigo 执行 git branch 显示所有本地分支，如果只存在一个分支，可以执行下面的命令获取另一分支的主题。 $ git branch * card # 获取远程 card 分支，并切换 $ git checkout -b card origin/card # 获取远程 master 分支，并切换 $ git checkout -b master origin/master 此命令只需执行一次，之后使用 git checkout [branch] 命令在两个主题之间切换。 依赖安装回到 blog 目录。 $ cd ../.. less主题默认使用 less 作为 css 预处理工具。 $ npm install hexo-renderer-less --save feedhexo-generator-feed 用于生成 rss。 $ npm install hexo-generator-feed --save json-content用于生成静态站点数据，用作站内搜索的数据源。 为了节约资源，可以对 jsonContent 插件生成的数据字段进行配置，减少数据文件大小。参考 hexo-generator-json-content。 $ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。可选，不安装时会请求 jiathis Api 生成二维码。 $ npm install hexo-helper-qrcode --save 开启标签页$ hexo new page tags INFO Created: ~/dev/blog/source/tags/index.md 修改 blog/source/tags/index.md 的元数据 --- title: tags date: 2017-06-18 18:35:37 layout: tags comments: false --- 开启分类页# 仅 card theme 支持 $ hexo new page categories INFO Created: ~/dev/blog/source/categories/index.md 修改 blog/source/categories/index.md 的元数据 --- title: categories date: 2017-06-18 18:41:23 layout: categories comments: false --- 配置主题hexo-theme-indigo 备份 blog 源码hexo-git-backup Jietu20180312-221423 $ ssh -T git@gitee.com Welcome to Gitee.com, CMF! 安装 hexo-git-backup # 如果 hexo 版本号是 2.x.x $ npm install hexo-git-backup@0.0.91 --save # 如果 hexo 版本号是 3.x.x $ npm install hexo-git-backup --save 配置 blog/_config.yml backup: type: git # 备份主题 ## theme: your theme name,your theme name ## theme/your theme name/.git 将会被移除 theme: indigo,landscape # 提交信息 message: update # 仓库 repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@gitcafe.com:xxx/xxx.git,branchName gitee: git@gitee.com:xxx/xxx.git,branchName 使用，如有权限问题，使用 sudo $ hexo backup # 或者 $ hexo b 克隆 blog 源码具备 Git、Node、Hexo 等环境后，执行以下命令。 $ git clone git@gitee.com:xxx/xxx.git blog $ cd blog $ npm install $ hexo server 批处理新建文本文档，复制粘贴以下代码，Mac 系统保存为 .sh 文件，Win 系统保存为 .bat 文件。 # 进入 blog 所在目录 cd /Users/cmf/dev/blog # 清除缓存文件 (db.json) 和已生成的静态文件 (public) # 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令 # 一般情况不执行 # hexo clean # 生成静态文件，简写：hexo g hexo generate # 部署网站，简写：hexo d hexo deploy # 备份源码，简写：hexo b hexo backup Hexo 常用命令# 初始化 $ hexo init # 清空静态页面 $ hexo clean # 生成静态页面 $ hexo generate $ hexo g # 本地测试 $ hexo server $ hexo s # 部署 $ hexo deploy $ hexo d # 新建文章 $ hexo new &quot;postName&quot; # 新建页面 $ hexo new page &quot;pageName&quot; # 查看帮助 $ hexo help 更多操作自定义页面绑定域名GitHub 中有篇文章介绍如何绑定域名：About supported custom domains 在 blog/source 目录下，新建命名为 CNAME 的文件，里面内容为需要绑定的域名，不包含 http、www 等前缀。如： cmflife.com 在终端使用 ping 指令查看 username.github.io 对应的 ip 地址 $ ping username.github.io 前往购买域名的平台进行 IPv4 域名解析，输入 ping 到的 ip 地址即可。 Q&amp;A访问 http://localhost:4000/ 无反应？ 一般是端口占用的原因。使用 Ctrl+C 中断本地服务，执行命令 hexo s -p 5000 更改端口号并重新开启本地服务，访问 http://localhost:5000/ 即可。 对项目中的部分文件进行修改后，预览时并没有生效？ 针对修改后没有生效的情况，一般是对配置文件进行了修改，需要 hexo clean 后才能生效。 hexo deploy 没反应？ 修改配置文件：_config.yml 时，冒号后面没加空格。 hexo backup 出错？ $ hexo backup Please make sure you have the correct access rights and the repository exists. ERROR: Repository not found. fatal: Could not read from remote repository. .git 中已经配置了远程仓库，导致更换仓库地址后出现这个问题，删掉 blog 目录中的 .git 文件夹，重新执行 hexo backup 。","tags":[{"name":"Blog","slug":"Blog","permalink":"https://mingfengst.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://mingfengst.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://mingfengst.github.io/tags/GitHub/"}]},{"title":"Node 的用法","date":"2014-06-18T06:22:46.000Z","path":"posts/2014/usage-node/","text":"Node 安装到 Node 官网 获取安装包。 注意：从官方链接下载安装包可能需要翻墙！ 安装过程建议保持默认设置，一路 next！但出于操作方便考虑，可以将 PATH 选项按照下图选择： Jietu20170620-151437 Git 的默认设置下，出于安全考虑，只有在 Git Bash 中才能进行 Git 的相关操作。按照上图的选择，将会使得 Git 安装程序在系统 PATH 中加入 Git 的相关路径，这样就可以在 CMD 界面下调用 Git，不用打开 Git Bash。 检查是否安装成功，能获取到对应版本号，则说明安装成功。 $ node -v $ npm -v 安装 cnpm，如有权限问题，使用 sudo 安装。 $ sudo npm install -g cnpm 设置 npm 淘宝镜像npm 默认源的下载速度可能很慢，建议替换成淘宝镜像。 $ npm config set registry &quot;https://registry.npm.taobao.org&quot; Node 常用命令# 查看 node 的版本号 $ node -v # 查看 npm 的版本号 $ npm -v","tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://mingfengst.github.io/tags/开发环境/"},{"name":"Node","slug":"Node","permalink":"https://mingfengst.github.io/tags/Node/"}]},{"title":"Git 的用法","date":"2014-06-18T05:32:05.000Z","path":"posts/2014/usage-git/","text":"Git 安装到 Git 官网 获取安装包。 注意：从官方链接下载安装包可能需要翻墙！ 安装过程建议保持默认设置，一路 next！ 检查是否安装成功，能获取到对应版本号，则说明安装成功。 $ git --version 注册 GitHub进入 GitHub 官网，已经有 GitHub 账号的可以直接 登录，还没有的需要 注册，根据提示输入用户名、Email、密码即可完成注册。 注意：GitHub 账号用户名一旦注册成功就不能修改。比如我的用户名是 mingfengst Git 配置配置 SSH在终端设置 user.name 和 user.email $ git config --global user.name &quot;your github user.name&quot; $ git config --global user.email &quot;your github user.email&quot; 生成 ssh 密钥 $ ssh-keygen -t rsa -C &quot;your github user.email&quot; # 设置保存的路径，密码（可直接回车跳过） Generating public/private rsa key pair. Enter file in which to save the key (/Users/cmf/.ssh/id_rsa): Created directory &#39;/Users/cmf/.ssh&#39;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/cmf/.ssh/id_rsa. Your public key has been saved in /Users/cmf/.ssh/id_rsa.pub. The key fingerprint is: SHA256:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX your github user.email The key&#39;s randomart image is: +---[RSA 2048]----+ | .. .. .X| | o .. . .| | o . = o . .o | | . X X + + o| | . . X O . o .| | . . . . X o . + | | + + o o . . o | | o*.=. . | | ..=*... | +----[SHA256]-----+ 此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的 ssh 密钥文件 id_rsa 和 id_rsa.pub。 添加 SSH 到 GitHub用户头像 → Settings → SSH and GPG keys → New SSH key → 将 id_rsa.pub 中的内容复制到 Key 文本框中，然后点击 Add SSH key（添加 SSH）按钮。 Jietu20180301-230037 Git 常用命令# 查看 git 的版本号 $ git --version # 查看 git 的安装路径（Mac） $ which git # 查看 git 的安装路径（Win） $ where git # 克隆仓库，默认与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为第二个参数 $ git clone &lt;版本库地址&gt; &lt;本地目录名&gt; # 查看分支，* 为当前分支 $ git branch # 新建分支 $ git branch &lt;分支名&gt; # 切换分支 $ git checkout &lt;分支名&gt; # 新建并切换到新分支 $ git checkout -b &lt;分支名&gt; # $ git add . # $ git commit -m &#39;提交备注&#39; # $ git push origin &lt;分支名&gt; # $ git update-ref -d HEAD 合并两个 git 仓库有 2 个 git 仓库：repo1 和 repo2，想要把这两个仓库进行合并，并且要保留以前的 commit 记录，即要把 repo1 中的文件移动到 repo2 中，并且之前 repo1 中的 commit 记录也要在 repo2 中保留。 repo1 仓库的目录树： repo2 仓库的目录树： 第一步：将 repo1 作为远程仓库，添加到 repo2 中，设置别名为 repo2_name。 [repo2] $ git remote add &lt;repo2_name&gt; &lt;repo2_path&gt; # eg: # [repo2] $ git remote add other ../reop1/ 第二步：从 repo1 中抓取数据到 repo2 仓库。 [repo2] $ git fetch &lt;repo2_name&gt; # eg: # [repo2] $ git fetch other # From ../reop1/ # * [new branch] master -&gt; other/master 第三步：将 repo1 仓库中抓取的 master 分支作为新分支 checkout 到 repo2，新分支名设置为 repo1。 $ git checkout -b repo1 other/master","tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://mingfengst.github.io/tags/开发环境/"},{"name":"Git","slug":"Git","permalink":"https://mingfengst.github.io/tags/Git/"}]},{"title":"Hello World","date":"2014-06-18T05:14:20.000Z","path":"posts/2014/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[]}]