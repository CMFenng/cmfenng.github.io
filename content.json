[{"title":"幸运转盘（canvas）","date":"2018-06-06T10:06:06.000Z","path":"posts/2018/canvas-lucky-draw/","text":"前言作为消费者，我们经常可以在双 11、双 12、618 等节日中看到拼手气的「幸运转盘」活动，大家都想成为那个幸运儿。那么，今天我们就用 canvas 来实现一个「幸运转盘」的案例，都来成为那个幸运儿。 需求分析 在页面上提供文件选择入口，并说明使用方法； 读取按要求编写的 txt 文件，解析出奖项及其中奖概率； 获取 canvas 元素，绘制转盘，注册点击事件； 产生随机数，实现转盘过渡效果； 自定义弹出框，展示抽奖结果。 代码实现文件入口文件的入口实现起来非常简单，直接用 HTML 提供的 input 交互式控件，设置 type 属性值为 file，accept 属性值为 .txt，限制可接受的文件类型，并且给控件绑定 change 事件。 另外，需要跟使用者说明文件规定的文本格式，以便能够正确解析出需要的数据。 主要代码如下： &lt;div id=&quot;fileBox&quot; class=&quot;frame center&quot;&gt; &lt;a class=&quot;btn no-select&quot;&gt; &lt;input type=&quot;file&quot; accept=&quot;.txt&quot; onchange=&quot;getFileDate(event)&quot;&gt;选 择 文 件 &lt;/a&gt; &lt;div id=&quot;describe&quot;&gt; &lt;p&gt;文件要求：&lt;/p&gt; &lt;p&gt; 格式：奖项=百分比(值越高越容易抽中)&lt;br&gt; &lt;br&gt; 一等奖=5&lt;br&gt; 二等奖=7&lt;br&gt; 三等奖=10&lt;br&gt; 四等奖=15&lt;br&gt; 五等奖=18&lt;br&gt; 六等奖=20&lt;br&gt; 谢谢参与=25 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;canvasBox&quot; class=&quot;no-select hide&quot;&gt; &lt;canvas id=&quot;plate&quot; width=&quot;600&quot; height=&quot;600&quot;&gt; 浏览器不支持！ &lt;/canvas&gt; &lt;canvas id=&quot;pointer&quot; width=&quot;200&quot; height=&quot;200&quot;&gt; 浏览器不支持！ &lt;/canvas&gt; &lt;button id=&quot;btn&quot;&gt;开始&lt;/br&gt;抽奖&lt;/button&gt; &lt;/div&gt; 页面结构就这么简单，但是默认的样式实在看不下去，我们重新定义下样式吧。 为了避免篇幅过长，css 代码就不在文章中贴出来了，代码已经托管到 GitHub，链接会在文章结尾给出。 截图如下，是不是好看多了： 读取文件新建一个文本文件，内容如下： 一等奖=5 二等奖=7 三等奖=10 四等奖=15 五等奖=18 六等奖=20 谢谢参与=25 这里使用了符号 = 进行字符串的分割，左侧是「奖项」，右侧是此奖项的「中奖概率」。特别注意的是，中奖概率之和肯定不能低于或者超过 100%，而且「奖项」和「中奖概率」是一一对应的关系。 HTML5 定义了 FileReader 用于读取存储在用户计算机上的文件的内容，正好符合我们的需求，部分代码如下： function getFileDate(e) { let file = e.target.files[0]; if (file) { let reader = new FileReader(); // 文件加载成功 reader.onload = function(event) { // 处理数据 let data = handleData(event.target.result); if (data !== undefined) { initPlate(data); } else { // 文件数据出错，清空文件选择框的值 e.target.value = &quot;&quot;; } }; // 加载文本 reader.readAsText(file); } } 得到文件的文本数据之后，需要对数据进行解析： function handleData(data) { let itemArr = data.split(&quot;\\n&quot;); let result = {}; // 存放奖项 result.text = []; // 存放百分比 result.radio = []; for (let i = 0; i &lt; itemArr.length; i++) { if (itemArr[i] === &quot;&quot;) { continue; } else { let itemKey = itemArr[i].split(&quot;=&quot;)[0]; let itemVal = itemArr[i].split(&quot;=&quot;)[1]; result.text.push(itemKey); if (itemVal !== &quot;&quot; &amp;&amp; !isNaN(+itemVal) &amp;&amp; typeof (+itemVal) == &quot;number&quot;) { result.radio.push(+itemVal); } } } // 奖项和百分比不能一一对应 if (result.text.length !== result.radio.length) { alert(&quot;文件错误！&quot;); return; // 百分比相加不等于 100 } else if (eval(result.radio.join(&quot;+&quot;)) !== 100) { alert(&quot;百分比错误！&quot;); return; } else { return result; } } 如果能够正常解析数据，那么 result 的值是这样的： { radio: [5, 7, 10, 15, 18, 20, 25], text: [&quot;一等奖&quot;, &quot;二等奖&quot;, &quot;三等奖&quot;, &quot;四等奖&quot;, &quot;五等奖&quot;, &quot;六等奖&quot;, &quot;谢谢参与&quot;] } 初始化转盘转盘主要分解为两部分：圆盘、指针。 这两部分都是用 canvas 来绘制，所以我们要先获取到页面中的 canvas 元素，再分别绘制这两个部分。 主要代码如下： function initPlate(data) { let plateCanvas = document.getElementById(&quot;plate&quot;); let plateCtx = plateCanvas.getContext(&quot;2d&quot;); let pointerCanvas = document.getElementById(&quot;pointer&quot;); let pointerCtx = pointerCanvas.getContext(&quot;2d&quot;); let btn = document.getElementById(&quot;btn&quot;); let lineW = 5; let num = data.text.length; let sectorDeg = 360 / num; let deg = Math.PI / 180; let round = 0; let initCircleDeg = -90-sectorDeg/2; initCircle(); initPointer(); // 注册点击事件 btn.onclick = function () { let randomNum = Math.random()*100; // [0, 100) round++; data.radio.reduce((prev, curv, i) =&gt; { if (randomNum &gt;= prev &amp;&amp; randomNum &lt; prev + curv) { runPlate(i, prev); } return prev + curv; }, 0); }; function runPlate(i) { btn.setAttribute(&quot;disabled&quot;, &quot;true&quot;); // 定时弹出框弹出 setTimeout(function () { alert(data.text[i]); }, 6500); plateCanvas.style.transform = `rotate(${ initCircleDeg + 3600*round + sectorDeg*(num-i) }deg)`; } } 可以看出，我们声明了一些变量，初始化线宽，初始角度等。圆盘和指针的绘制分别用函数 initCircle 和 initPointer 来完成，后面再单独说明。除此之外，声明了转盘转动的方法，并注册了点击事件，在点击事件的处理函数里产生了随机数。 绘制圆盘圆盘是由多个扇形拼接而成的，解析完文件的文本数据之后，就可以知道扇形的数量、角度。由于每个扇形的绘制过程都是一个重复性的过程，所以我们封装一个方法来实现： /** * @param ctx canvas 的 context 实例 * @param x x 轴坐标 * @param y y 轴坐标 * @param r 半径 * @param sDeg 扇形开始的弧度 * @param eDeg 扇形结束的弧度 * @param text 文本 */ function drawSector(ctx, x, y, r, sDeg, eDeg, text) { ctx.save(); ctx.translate(x, y); ctx.beginPath(); ctx.arc(0, 0, r, sDeg, eDeg); ctx.lineWidth = lineW; ctx.strokeStyle = &quot;#40AA53&quot;; ctx.stroke(); ctx.lineWidth = 1; ctx.strokeStyle = &quot;#40AA53&quot;; ctx.save(); ctx.rotate(sDeg); ctx.lineTo(0, 0); ctx.stroke(); ctx.lineTo(r, 0); ctx.stroke(); ctx.fillStyle = &quot;#0ff&quot;; ctx.fill(); ctx.moveTo(0, 0); ctx.restore(); ctx.save(); ctx.rotate(Math.PI/2 + eDeg-(eDeg-sDeg)/2); ctx.fillStyle = &quot;#cc0000&quot;; ctx.font = &quot;30px Microsoft YaHei&quot;; ctx.textAlign = &quot;center&quot;; ctx.fillText(text, 0, -r*2/3); ctx.restore(); ctx.closePath(); ctx.restore(); } 可能看代码不够形象，可以看看动画： 封装完绘制扇形的方法，就可以根据「奖项」的数量来循环绘制扇形，从而拼接成圆盘： function initCircle() { plateCanvas.style.transform = `rotate(${ initCircleDeg }deg)`; let plateCenterX = plateCanvas.width/2; let plateCenterY = plateCanvas.height/2; let plateR = plateCenterX &lt; plateCenterY ? plateCenterX-lineW : plateCenterY-lineW; for (let i = 0; i &lt; num; i++) { drawSector(plateCtx, plateCenterX, plateCenterY, plateR, sectorDeg*i*deg, sectorDeg*(i+1)*deg, data.text[i]); } plateCanvas.style.transition = `transform 6s`; } 从上面的代码可以看出，为了让第一个「奖项」位于圆盘的正上方，将圆盘进行了旋转，并设置了 6s 的过渡时长，为后面转动转盘做准备。 绘制指针指针是要固定要圆盘的中心的，并且将指针的方向指向了圆盘的正上方，实现的代码如下： function initPointer() { pointerCanvas.style.transform = `translate(-50%, -50%) rotate(-90deg)`; let pointerCenterX = pointerCanvas.width/2; let pointerCenterY = pointerCanvas.height/2; let pointerR = pointerCenterX &lt; pointerCenterY ? pointerCenterX/2 : pointerCenterY/2; pointerCtx.save(); pointerCtx.beginPath(); pointerCtx.arc(pointerCenterX, pointerCenterY, pointerR, Math.PI/10, Math.PI*2-Math.PI/10); pointerCtx.lineTo(pointerCenterX+pointerR*2, pointerCenterY); pointerCtx.closePath(); pointerCtx.fillStyle = &quot;#ff0000&quot;; pointerCtx.fill(); } 到这里，绘制过程就完成了，来看看转盘的效果： 自定义弹出框浏览器默认的弹出框样式跟我们案例的风格明显不符，我们来试下自定义下： &lt;script&gt; window.alert = function (str) { let alertBox = document.createElement(&quot;div&quot;); alertBox.id = &quot;alertBox&quot;; alertBox.className = &quot;frame center no-select&quot;; let htmlStr = ` &lt;div id=&quot;title&quot;&gt;抽奖结果&lt;/div&gt; &lt;div id=&quot;info&quot;&gt;${ str }&lt;/div&gt; &lt;button class=&quot;btn&quot; onclick=&quot;doOk()&quot;&gt;确 定&lt;/button&gt; `; alertBox.innerHTML = htmlStr; document.body.appendChild(alertBox); this.doOk = function(){ document.body.removeChild(alertBox); // 重新使能按钮 document.getElementById(&quot;btn&quot;).removeAttribute(&quot;disabled&quot;); }; alertBox.focus(); } &lt;/script&gt; 直接上效果图： 怎么样？整体风格是不是好很多？ 链接 看看有详细注释的源码 在线预览，体验一波","tags":[{"name":"Demo","slug":"Demo","permalink":"https://mingfengst.github.io/tags/Demo/"},{"name":"Canvas","slug":"Canvas","permalink":"https://mingfengst.github.io/tags/Canvas/"}]},{"title":"Node 的基本用法","date":"2016-06-18T05:22:46.000Z","path":"posts/2016/usage-node/","text":"Node 的安装Node 的安装方式很简单，只要到 Node 的官网 下载好安装包然后双击安装即可。 安装的过程建议保持默认设置，一路 next！但出于操作方便考虑，可以将 PATH 选项按照下图选择： 出于安全考虑，Git 的默认设置下，只有在 Git Bash 中才能进行 Git 的相关操作。在安装过程中，可以选择 Use Git from the Windows Command Prompt，将 Git 安装程序在系统 PATH 中加入 Git 的相关路径，这样就可以在 CMD 命令行下调用 Git，不需要打开 Git Bash。 macOS 可以使用 homebrew 进行安装： $ brew install node 安装完成后，检查是否安装成功，能获取对应版本号说明安装成功： # 查看 node 的版本号 $ node -v # 查看 npm 的版本号 $ npm -v 安装 cnpm，如有权限问题，使用 sudo 安装： $ sudo npm install -g cnpm 设置 npm 淘宝镜像npm 默认源的下载速度可能很慢，建议替换成淘宝镜像： $ npm config set registry &quot;https://registry.npm.taobao.org&quot;","tags":[{"name":"Node","slug":"Node","permalink":"https://mingfengst.github.io/tags/Node/"}]},{"title":"Hello World","date":"2016-06-18T05:14:20.000Z","path":"posts/2016/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[]}]