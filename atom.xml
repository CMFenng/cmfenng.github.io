<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CMF | Blog</title>
  
  <subtitle>Just Do IT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mingfengst.github.io/"/>
  <updated>2018-04-20T03:03:17.295Z</updated>
  <id>https://mingfengst.github.io/</id>
  
  <author>
    <name>CMF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac 使用 tree 生成目录结构</title>
    <link href="https://mingfengst.github.io/posts/2017/mac-usage-tree/"/>
    <id>https://mingfengst.github.io/posts/2017/mac-usage-tree/</id>
    <published>2017-11-13T08:21:32.000Z</published>
    <updated>2018-04-20T03:03:17.295Z</updated>
    
    <content type="html"><![CDATA[<p>写文章时，经常需要将一个目录的结构列出来。或许可以直接截图贴上来，但有时图片并不能体现出完整的结构。下面，将使用 tree 来实现这种效果。</p><pre><code class="txt">.├── README.md├── _config.yml├── package-lock.json├── package.json├── scaffolds│   ├── draft.md│   ├── page.md│   └── post.md├── source│   ├── 404.html│   ├── CNAME│   ├── _posts│   ├── categories│   ├── plugins│   └── tags└── themes    ├── indigo    └── landscape</code></pre><h2 id="tree-安装"><a href="#tree-安装" class="headerlink" title="tree 安装"></a>tree 安装</h2><p>macOS 下直接使用 Homebrew 安装。</p><pre><code class="bash">$ brew install tree</code></pre><h2 id="tree-常用命令"><a href="#tree-常用命令" class="headerlink" title="tree 常用命令"></a>tree 常用命令</h2><pre><code class="bash"># 打印当前目录下的所有文件$ tree$ tree -a# 只打印目录$ tree -d# 限制追溯的目录层级。n 表示层级数$ tree -L n# 只列出与给定模式匹配的文件，pattern 可以是正则表达式$ tree -P pattern    # eg: tree -P &#39;*.jpg&#39;# 不列出与给定模式匹配的文件，pattern 可以是正则表达式$ tree -I pattern    # eg: tree -I &#39;node_modules&#39;# 模式匹配时忽略大小写$ tree -I pattern --ignore-case    # eg: tree -I &#39;*.JPG&#39; --ignore-case# 复合写法：不列出 node_modules 目录，且限制追溯层级为 3$ tree -L 3 -I &quot;node_modules&quot;# 不要追溯到文件数超过 # 的目录中$ tree --filelimit #    # eg: tree --filelimit 7# 输出到文件而不是标准输出流$ tree -o filename    # eg: tree -o tree.html$ tree &gt; filename    # eg: tree &gt; tree.html# 按原样打印不可打印的字符，默认情况下中文会被显示为一串转义字符，使用 -N 可以显示出中文$ tree -N# 打印 dir 目录下的所有文件，以及权限$ tree -p &lt;dir&gt;    # eg: tree -p img# 打印每个文件的字节大小$ tree -s# 打印 dir 目录下的所有文件，以及人类通俗易懂的大小$ tree -h &lt;dir&gt;# 选择排序：name，version，size，mtime，ctime$ tree --sort=size# 总是打开彩色显示。在文件和目录清单上加色彩，便于区分各种类型$ tree -C# 以 baseHREF 为顶部目录打印 HTML 格式$ tree -H baseHREF    # eg: tree -H . -o tree.html# 用 string 替换默认的 HTML 标题和 H1 标题$ tree -T string    # eg: tree -T &#39;树结构&#39; -H . -o tree.html# 关闭 HTML 输出中的超链接$ tree --nolinks    # eg: tree --nolinks -H . -o tree.html</code></pre><h2 id="解读-tree-–help"><a href="#解读-tree-–help" class="headerlink" title="解读 tree –help"></a>解读 tree –help</h2><pre><code class="bash">$ tree --helpusage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ]    [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version]    [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst]    [--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;]    [--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;]  ------- Listing options -------  -a            # All files are listed.                # 列出所有文件。  -d            # List directories only.                # 只列出目录。  -l            # Follow symbolic links like directories.                # 遵循像目录一样的符号链接。  -f            # Print the full path prefix for each file.                # 在每个文件的前面打印完整的相对路径。  -x            # Stay on current filesystem only.                # 只停留在当前文件系统。若指定目录下的某些子目录存在另一个文件系统上，则排除该子目录。  -L level      # Descend only level directories deep.                # 只追溯到目录的 level 级。  -R            # Rerun tree when max dir level reached.                # 当达到最大目录层级时重新运行树。  -P pattern    # List only those files that match the pattern given.                # 只列出与给定模式匹配的文件。  -I pattern    # Do not list files that match the given pattern.                # 不列出与给定模式匹配的文件。  --ignore-case # Ignore case when pattern matching.                # 模式匹配时忽略大小写。  --matchdirs   # Include directory names in -P pattern matching.                # 在 -P 模式匹配中包含目录名。  --noreport    # Turn off file/directory count at end of tree listing.                # 在树列表的末尾关闭文件/目录计数。  --charset X   # Use charset X for terminal/HTML and indentation line output.                # 为终端/HTML和压痕线输出指定字符集 X。  --filelimit # # Do not descend dirs with more than # files in them.                # 不要追溯到文件数超过 # 的目录中。  --timefmt &lt;f&gt; # Print and format time according to the format &lt;f&gt;.                # 根据格式 &lt;f&gt; 打印和格式化时间。  -o filename   # Output to file instead of stdout.                # 输出到文件而不是标准输出流。  -------- File options ---------  -q            # Print non-printable characters as &#39;?&#39;.                # 打印不可打印的字符为 &#39;?&#39;。  -N            # Print non-printable characters as is.                # 按原样打印不可打印的字符。  -Q            # Quote filenames with double quotes.                # 用双引号引用文件名。  -p            # Print the protections for each file.                # 打印每个文件的权限。  -u            # Displays file owner or UID number.                # 显示文件所有者或者 UID 号。  -g            # Displays file group owner or GID number.                # 显示文件组所有者或者 GID 号。  -s            # Print the size in bytes of each file.                # 打印每个文件的字节大小。  -h            # Print the size in a more human readable way.                # 以人类通俗易懂的方式打印文件的大小。  --si          # Like -h, but use in SI units (powers of 1000).                # 类似 -h，但使用的是 SI 单位（1000 的幂）。  -D            # Print the date of last modification or (-c) status change.                # 打印最后修改或者（-c）状态更改的日期。  -F            # Appends &#39;/&#39;, &#39;=&#39;, &#39;*&#39;, &#39;@&#39;, &#39;|&#39; or &#39;&gt;&#39; as per ls -F.                # 附加 &#39;/&#39;，&#39;=&#39;，&#39;*&#39;，&#39;@&#39;，&#39;|&#39; 或 &#39;&gt;&#39;，如 ls -F。  --inodes      # Print inode number of each file.                # 打印每个文件的 inode 号。  --device      # Print device ID number to which each file belongs.                # 打印每个文件所属的设备 ID 号。  ------- Sorting options -------  -v            # Sort files alphanumerically by version.                # 按字母数字排序文件。  -t            # Sort files by last modification time.                # 按最后修改时间排序文件。  -c            # Sort files by last status change time.                # 按最后状态改变时间排序文件。  -U            # Leave files unsorted.                # 把文件分类。  -r            # Reverse the order of the sort.                # 倒序排序。  --dirsfirst   # List directories before files (-U disables).                # 在列出文件之前先列出目录（-U 无效）。  --sort X      # Select sort: name,version,size,mtime,ctime.                # 选择排序：name，version，size，mtime，ctime。  ------- Graphics options ------  -i            # Don&#39;t print indentation lines.                # 不打印压痕线。不以阶梯状列出文件或目录名称。  -A            # Print ANSI lines graphic indentation lines.                # 打印 ANSI 线图形压痕线。使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。  -S            # Print with CP437 (console) graphics indentation lines.                # 打印带有 CP437（控制台）图像压痕线。  -n            # Turn colorization off always (-C overrides).                # 总是关闭彩色显示（-C 覆盖）。  -C            # Turn colorization on always.                # 总是打开彩色显示。在文件和目录清单上加色彩，便于区分各种类型。  ------- XML/HTML/JSON options -------  -X            # Prints out an XML representation of the tree.                # 打印出树的 XML 表示。  -J            # Prints out an JSON representation of the tree.                # 打印出树的 JSON 表示。  -H baseHREF   # Prints out HTML format with baseHREF as top directory.                # 以 baseHREF 为顶部目录打印 HTML 格式。  -T string     # Replace the default HTML title and H1 header with string.                # 用 string 替换默认的 HTML 标题和 H1 标题。  --nolinks     # Turn off hyperlinks in HTML output.                # 关闭 HTML 输出中的超链接。  ---- Miscellaneous options ----  --version     # Print version and exit.                # 打印版本号后退出。  --help        # Print usage and this help message and exit.                # 打印用法和帮助信息后退出。  --            # Options processing terminator.                # 选项处理终结者。</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.jb51.net/article/100123.htm" target="_blank" rel="noopener">Liunx系统命令中tree命令详解</a></li><li><a href="http://www.jb51.net/article/85917.htm" target="_blank" rel="noopener">一天一个shell命令 linux文本操作系列-tree命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写文章时，经常需要将一个目录的结构列出来。或许可以直接截图贴上来，但有时图片并不能体现出完整的结构。下面，将使用 tree 来实现这种效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;txt&quot;&gt;.
├── README.md
├── _config.yml
├── pac
      
    
    </summary>
    
      <category term="工具" scheme="https://mingfengst.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="https://mingfengst.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew 的用法</title>
    <link href="https://mingfengst.github.io/posts/2017/mac-usage-homebrew/"/>
    <id>https://mingfengst.github.io/posts/2017/mac-usage-homebrew/</id>
    <published>2017-11-11T02:26:45.000Z</published>
    <updated>2018-04-27T06:24:20.832Z</updated>
    
    <content type="html"><![CDATA[<p>Homebrew 是 macOS 系统中最受欢迎的包管理工具，以最简单、最灵活的方式来安装苹果公司在 macOS 中不包含的 UNIX 工具。</p><p><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew 官网</a><br><a href="https://docs.brew.sh/" target="_blank" rel="noopener">Homebrew 文档</a></p><h2 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h2><p>拥有她只需要简单的3步：</p><p>安装Xcode（Mac App Store免费一键下载）<br>安装homebrew（一行命令直接搞定，easy）<br>安装homebrew-cask（也是一行命令搞定，一点难度都木有）</p><p>brew cask search 列出所有可以被安装的软件<br>brew cask search drop 查找所有和 drop 相关的应用<br>brew cask info thunder 查看 迅雷 应用的信息，这货安装的可是最新版本的迅雷哦！</p><p>brew cask install qq 安装QQ</p><p>brew cask uninstall qq 卸载 QQ</p><p>brew cask list 查看安装了哪些软件</p><pre><code class="bash"># 到目前October 5, 2013 1:43 PM为止，homebrew-cask共收录566款应用程序# 瞬间安装所有常用软件brew cask install alfredbrew cask install the-unarchiverbrew cask install qqbrew cask install linebrew cask install skypebrew cask install thunderbrew cask install mplayerxbrew cask install evernotebrew cask install skitchbrew cask install dropboxbrew cask install google-chromebrew cask install moubrew cask install iterm2brew cask install sublime-textbrew cask install virtualbox</code></pre><p>已安装<br>brew list</p><pre><code>tree</code></pre><p>brew cask list</p><pre><code>webstorm</code></pre><p>安装 Homebrew 之前，需要先安装 Xcode Command Line Tools</p><p>Homebrew 的安装很简单，只要打开终端执行以下命令。</p><pre><code class="bash">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>终端会让用户确认是否继续安装所列出来的脚本。按 <code>RETURN</code> 键继续，之后可能需要输入用户密码，就可以安装完成了。</p><pre><code class="bash">Press RETURN to continue or any other key to abort</code></pre><p>检查是否安装成功，能获取到对应版本号，则说明安装成功。</p><pre><code class="bash">$ brew -v</code></pre><p>卸载</p><pre><code class="bash">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</code></pre><h2 id="Homebrew-常用命令"><a href="#Homebrew-常用命令" class="headerlink" title="Homebrew 常用命令"></a>Homebrew 常用命令</h2><pre><code class="bash"># 安装软件$ brew install formula# 卸载软件$ brew uninstall formula# 搜索软件$ brew search formula# 更新软件$ brew upgrade formula# 查看安装列表$ brew list# 更新 Homebrew$ brew update</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Homebrew 是 macOS 系统中最受欢迎的包管理工具，以最简单、最灵活的方式来安装苹果公司在 macOS 中不包含的 UNIX 工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://brew.sh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="工具" scheme="https://mingfengst.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="https://mingfengst.github.io/tags/Mac/"/>
    
      <category term="Homebrew" scheme="https://mingfengst.github.io/tags/Homebrew/"/>
    
  </entry>
  
  <entry>
    <title>命名规则</title>
    <link href="https://mingfengst.github.io/posts/2014/naming-rule/"/>
    <id>https://mingfengst.github.io/posts/2014/naming-rule/</id>
    <published>2014-07-01T05:24:58.000Z</published>
    <updated>2018-04-05T13:50:10.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>规范的命名在程序开发中有明显的优势，它即能让自己日后维护简单，也能让团队友好的合作，在网页开发中，特别是团队合作，命名是非常重要的。</p><h2 id="页面命名"><a href="#页面命名" class="headerlink" title="页面命名"></a>页面命名</h2><h3 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h3><pre><code class="bash"># 外围wrapper# 主体main# 内容content | container# 页头header# 页脚 | 页尾footer# 中middle | center# 上top# 下bottom# 左left# 右right</code></pre><h3 id="页面分区"><a href="#页面分区" class="headerlink" title="页面分区"></a>页面分区</h3><pre><code class="bash"># 菜单menu# 子菜单submenu# 标题title# 标志logo# 图标icon# 导航nav# 主导航mainbav# 子导航subnav# 顶导航topnav# 边导航 | 侧栏sidebar# 栏目 | 纵栏column# 左导航leftsidebar# 右导航rightsidebar# 标签页tab# 登录条loginbar# 购物车shop# 广告banner# 热点hot# 新闻news# 摘要summary# 文章列表list# 状态status# 提示信息msg# 小技巧tips# 指南guide# 服务service# 加入joinus# 版权copyright# 友情链接friendlink | link# 合作伙伴partner</code></pre><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><pre><code class="bash"># 登录login | log# 注册regsiter | reg# 下载download# 搜索search# 滚动scroll# 投票vote# 当前的current# 注释note</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><pre><code class="bash"># 按钮btn# 输入框ipt</code></pre><h2 id="样式命名"><a href="#样式命名" class="headerlink" title="样式命名"></a>样式命名</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>使用颜色的名称或者 16 进制代码。</p><pre><code class="css">.red { color: red; }.f60 { color: #f60; }.ff8600 { color: #ff8600; }</code></pre><h3 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h3><p>直接使用 “font + 字体大小”。</p><pre><code class="css">.font12px { font-size: 12px; }.font9pt { font-size: 9pt; }</code></pre><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>使用对齐目标的英文名称。</p><pre><code class="css">.left { float: left; }.bottom { float: bottom; }</code></pre><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>使用 “类别+功能” 的方式。</p><pre><code class="css">.barnews { }.barproduct { }</code></pre><h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><ol><li>一律小写。</li><li>尽量用英文。</li><li>不加中杆和下划线。</li><li>尽量不缩写，除非一看就明白的单词。</li></ol><pre><code class="bash"># 主要的master.css# 模块module.css# 基本共用base.css# 主题themes.css# 专栏columns.css# 打印print.css# 文字font.css# 表单forms.css# 补丁mend.css# 布局 | 版面layout.css</code></pre><h2 id="注释写法"><a href="#注释写法" class="headerlink" title="注释写法"></a>注释写法</h2><pre><code class="css">/* Footer */内容区/* End Footer */</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;规范的命名在程序开发中有明显的优势，它即能让自己日后维护简单，也能让团队友好的合作，在网页开发中，特别是团队合作，命名是非常重要的。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Web" scheme="https://mingfengst.github.io/categories/Web/"/>
    
    
      <category term="规范" scheme="https://mingfengst.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>修改博客代码块的语法高亮风格</title>
    <link href="https://mingfengst.github.io/posts/2014/blog-code-highlight/"/>
    <id>https://mingfengst.github.io/posts/2014/blog-code-highlight/</id>
    <published>2014-06-19T06:07:42.000Z</published>
    <updated>2018-04-20T03:02:01.505Z</updated>
    
    <content type="html"><![CDATA[<p>刚用 Hexo+GitHub 搭建个人博客并更换 indigo 主题后，由于个人对里面代码块的语法高亮风格并不喜欢，就自己尝试着更换风格。这里以我使用的 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo 主题</a> 为例，总结出以下几种方式。</p><h2 id="直接修改配色方案"><a href="#直接修改配色方案" class="headerlink" title="直接修改配色方案"></a>直接修改配色方案</h2><p>如果只是不喜欢代码块的语法高亮配色方案，那么直接修改项目中的 <code>highlight.less</code> 文件即可。可以参考这里的 <a href="https://github.com/chriskempson/tomorrow-theme" target="_blank" rel="noopener">配色方案</a>。</p><p>修改 <code>blog/themes/indigo/source/css/_partial/highlight.less</code> 的配色方案或样式。</p><pre><code class="less">// Tomorrow Night Bright@h-background: #000000;@h-current-line: #2a2a2a;@h-selectioon: #424242;@h-foreground: #eaeaea;@h-comment: #969896;@h-red: #d54e53;@h-orange: #e78c45;@h-yellow: #e7c547;@h-green: #b9ca4a;@h-aqua: #70c0b1;@h-blue: #7aa6da;@h-purple: #c397d8;</code></pre><p>修改 <code>blog/_config.yml</code> 的配置，将 <code>highlight.enable</code> 的值设置为 <code>true</code>。</p><pre><code class="yaml"># 代码块的设置highlight:  enable: true</code></pre><p>如果你对样式也要做些改动，那么可以修改 <code>blog/themes/indigo/layout/_partial/head.ejs</code> 的模板。</p><pre><code class="ejs">&lt;!-- 主题默认的代码语法高亮风格：修改样式 --&gt;&lt;% if (config.highlight.enable) { %&gt;    &lt;style&gt;        .post-content .highlight {            padding: 0.8em;            margin-left: 0;            margin-right: 0;            border-radius: 5px;        }        .post-content .highlight pre {            background: transparent;        }        /* 滚动条轨道 */        ::-webkit-scrollbar-track {            border-radius: 5px;        }    &lt;/style&gt;&lt;% } %&gt;&lt;!-- 建议在文件中找到下面这句代码，在此前面进行修改 --&gt;&lt;script&gt;window.lazyScripts=[]&lt;/script&gt;</code></pre><h2 id="引入-highlight-js"><a href="#引入-highlight-js" class="headerlink" title="引入 highlight.js"></a>引入 highlight.js</h2><p>引入 <a href="https://highlightjs.org/" target="_blank" rel="noopener">highlight.js</a> 实现代码的语法高亮，使用起来比较灵活，可以 <a href="https://highlightjs.org/static/demo/" target="_blank" rel="noopener">预览</a> 不同的语法高亮风格，也可以根据你需要实现高亮的语言 <a href="https://highlightjs.org/download/" target="_blank" rel="noopener">自定义</a> highlight.js 并下载，使 highlight.js 更轻量，更多用法可以查看 <a href="https://highlightjs.org/usage/" target="_blank" rel="noopener">这里</a>。</p><p>以 monokai-sublime 风格为例。将下载完的 <code>highlight.zip</code> 进行解压，并将 <code>monokai-sublime.css</code> 和 <code>highlight.pack.js</code> 文件拷贝到 <code>blog/source/plugins/highlight</code> 目录下。</p><p>修改 <code>blog/_config.yml</code> 的配置，跳过 <code>plugins</code> 目录下所有文件的渲染。</p><pre><code class="yaml"># 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径## glob 表达式：https://github.com/isaacs/node-globskip_render:  - &#39;plugins/**&#39;</code></pre><p>修改 <code>blog/_config.yml</code> 的配置，将 <code>highlight.enable</code> 的值设置为 <code>false</code>，并配置引入文件的路径。</p><pre><code class="yaml"># 代码块的设置highlight:  enable: false  # 引入 highlight.js，自定义代码语法高亮风格  hl_custom:    # css 路径    css_path: plugins/highlight/monokai-sublime.css    # js 路径    js_path: plugins/highlight/highlight.pack.js</code></pre><p>修改 <code>blog/themes/indigo/layout/_partial/head.ejs</code> 的模板。引入 css 和 js 文件，并对部分样式进行修改。</p><pre><code class="ejs">&lt;!-- 建议在文件中找到下面这句代码，在此后面进行修改 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(theme_css(&#39;/css/style&#39;, cache)) %&gt;&quot;&gt;&lt;!-- 自定义的代码语法高亮风格：引入 highlight.js --&gt;&lt;% if (!config.highlight.enable) { %&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(config.highlight.hl_custom.css_path) %&gt;&quot;&gt;    &lt;script src=&quot;&lt;%- url_for(config.highlight.hl_custom.js_path) %&gt;&quot;&gt;&lt;/script&gt;    &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;    &lt;script&gt;        Array.prototype.slice.call(document.querySelectorAll(&#39;pre code&#39;)).forEach(function(block) {            hljs.highlightBlock(block);        })    &lt;/script&gt;    &lt;style&gt;        .post-content pre {            padding: 0;            margin-left: 0;            margin-right: 0;            border-radius: 5px;        }    &lt;/style&gt;&lt;% } %&gt;</code></pre><p>修改过程中保留了原来的样式表，样式表的优先级对引入 highlight.js 后的语法高亮效果和样式产生了影响，因此可以在 <code>monokai-sublime.css</code> 中将被影响的属性加上 <code>!important</code>，让其优先级最高。要是不确定哪个属性被影响了，可以给全部属性加上 <code>!important</code>。</p><p>通过对项目的修改，<code>highlight.enable</code> 的值与之前表示的有所不同：</p><ul><li><code>true</code>：使用主题默认的高亮风格</li><li><code>false</code>：使用 highlight.js 自定义的高亮风格</li></ul><p>因此，我们可以通过修改 <code>highlight.enable</code> 的值，快速地切换主题默认的代码语法高亮风格和自定义的代码语法高亮风格。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ieclipse.cn/2016/07/18/Web/Hexo-dev-highlight/" target="_blank" rel="noopener">Hexo高级教程之代码高亮</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚用 Hexo+GitHub 搭建个人博客并更换 indigo 主题后，由于个人对里面代码块的语法高亮风格并不喜欢，就自己尝试着更换风格。这里以我使用的 &lt;a href=&quot;https://github.com/yscoder/hexo-theme-indigo&quot; targe
      
    
    </summary>
    
      <category term="Web" scheme="https://mingfengst.github.io/categories/Web/"/>
    
    
      <category term="Blog" scheme="https://mingfengst.github.io/tags/Blog/"/>
    
      <category term="Hexo" scheme="https://mingfengst.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub 搭建个人博客</title>
    <link href="https://mingfengst.github.io/posts/2014/blog-base-on-hexo-and-github/"/>
    <id>https://mingfengst.github.io/posts/2014/blog-base-on-hexo-and-github/</id>
    <published>2014-06-18T07:46:17.000Z</published>
    <updated>2018-04-25T09:40:55.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文是一篇基于 GitHub Pages 的 Hexo 博客搭建教程。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>安装 Hexo 相当简单。然而在安装前，先检查电脑中是否已安装下列应用程序：</p><ul><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li></ul><p>安装方法：参考文章 <a href="/posts/2014/usage-git">Git 的用法</a>、<a href="/posts/2014/usage-node">Node 的用法</a>。</p><p>检查方法：打开终端，依次输入以下命令，能获取到对应版本号，则说明安装成功。</p><pre><code class="bash"># 查看 node 的版本号node -v# 查看 npm 的版本号npm -v# 查看 git 的版本号git --version</code></pre><p>如果电脑中已具备以上条件，那么只需要使用 npm 即可完成 Hexo 的全局安装。如有权限问题，使用 sudo 安装。</p><pre><code class="bash">$ npm install -g hexo-cli$ sudo npm install -g hexo-cli</code></pre><p>检查是否安装成功，能获取到对应版本号，则说明安装成功。</p><pre><code class="bash">$ hexo -v</code></pre><h3 id="创建-blog-仓库"><a href="#创建-blog-仓库" class="headerlink" title="创建 blog 仓库"></a>创建 blog 仓库</h3><p>登录 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 账号，点击页面右上角的 <code>+</code>，选择 New repository。</p><p>博客仓库名必须是：username.github.io。比如我的博客仓库名是：<a href="https://mingfengst.github.io/">mingfengst.github.io</a>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/cmf/Desktop/essay/img/Jietu20180312-164955.jpg" alt="Jietu20180312-164955" title="">                </div>                <div class="image-caption">Jietu20180312-164955</div>            </figure><h3 id="开启-gh-pages"><a href="#开启-gh-pages" class="headerlink" title="开启 gh-pages"></a>开启 gh-pages</h3><p>点击界面右侧的 Settings，将会打开这个库的 setting 页面，向下拖动，直到看见 GitHub Pages，点击 Automatic page generator，GitHub 将会自动替你创建出一个 gh-pages 的页面。如果配置没问题的话，username.github.io 这个网址就可以正常访问了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/cmf/Desktop/essay/img/Jietu20180312-165843.jpg" alt="Jietu20180312-165843" title="">                </div>                <div class="image-caption">Jietu20180312-165843</div>            </figure><h2 id="创建-blog-项目"><a href="#创建-blog-项目" class="headerlink" title="创建 blog 项目"></a>创建 blog 项目</h2><p>初始化 hexo 项目，文件名以 blog 为例。</p><pre><code class="bash">$ hexo init blog</code></pre><p>进入 blog 目录</p><pre><code class="bash">$ cd blog</code></pre><p>安装依赖</p><pre><code class="bash">$ npm install</code></pre><p>生成静态页面</p><pre><code class="bash">$ hexo generate</code></pre><p>本地启动测试</p><pre><code class="bash">$ hexo server  INFO  Start processing  INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/cmf/Desktop/essay/img/Jietu20180312-211146.jpg" alt="Jietu20180312-211146" title="">                </div>                <div class="image-caption">Jietu20180312-211146</div>            </figure><p>打开浏览器，地址栏中输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，即可看见刚刚创建的博客了。</p><h2 id="部署-blog-项目"><a href="#部署-blog-项目" class="headerlink" title="部署 blog 项目"></a>部署 blog 项目</h2><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>。</p><pre><code class="bash">$ npm install hexo-deployer-git --save</code></pre><p>修改 _config.yml 配置文件。</p><pre><code class="yaml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  # 库（Repository）地址  repo: git@github.com:mingfengst/mingfengst.github.io.git  # 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。  branch: master  # 自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})  message:</code></pre><blockquote><p>注意：</p><p>type: git 中的冒号后面有空格。</p><p>将 repo 替换成自己的 repository。</p></blockquote><p>部署。</p><pre><code class="bash">$ hexo deploy</code></pre><p>打开浏览器，在地址栏输入 <a href="https://username.github.io" target="_blank" rel="noopener">https://username.github.io</a> 即可访问托管在 GitHub 上的博客。如我的博客地址是：<a href="https://mingfengst.github.io">https://mingfengst.github.io</a> 。</p><h2 id="更改-blog-配置"><a href="#更改-blog-配置" class="headerlink" title="更改 blog 配置"></a>更改 blog 配置</h2><p><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration.html</a></p><h2 id="更换-blog-主题"><a href="#更换-blog-主题" class="headerlink" title="更换 blog 主题"></a>更换 blog 主题</h2><p>可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里</a>选择自己喜欢的主题。</p><p>以 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">hexo-theme-indigo</a> 为例。</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>要求：Hexo 版本在 3.0 以上，Node 版本为 6.x 以上。</p><p>进入 blog 目录，下载主题。</p><pre><code class="bash">$ git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</code></pre><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>进入 themes/indigo 目录。</p><pre><code class="bash">$ cd themes/indigo</code></pre><p>执行 <code>git branch</code> 显示所有本地分支，如果只存在一个分支，可以执行下面的命令获取另一分支的主题。</p><pre><code class="bash">$ git branch  * card# 获取远程 card 分支，并切换$ git checkout -b card origin/card# 获取远程 master 分支，并切换$ git checkout -b master origin/master</code></pre><p>此命令只需执行一次，之后使用 <code>git checkout [branch]</code> 命令在两个主题之间切换。</p><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><p>回到 blog 目录。</p><pre><code class="bash">$ cd ../..</code></pre><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>主题默认使用 less 作为 css 预处理工具。</p><pre><code class="bash">$ npm install hexo-renderer-less --save</code></pre><h4 id="feed"><a href="#feed" class="headerlink" title="feed"></a>feed</h4><p><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a></p><p>用于生成 rss。</p><pre><code class="bash">$ npm install hexo-generator-feed --save</code></pre><h4 id="json-content"><a href="#json-content" class="headerlink" title="json-content"></a>json-content</h4><p>用于生成静态站点数据，用作站内搜索的数据源。</p><p>为了节约资源，可以对 jsonContent 插件生成的数据字段进行配置，减少数据文件大小。参考 <a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a>。</p><pre><code class="bash">$ npm install hexo-generator-json-content --save</code></pre><h4 id="QRCode"><a href="#QRCode" class="headerlink" title="QRCode"></a>QRCode</h4><p>用于生成微信分享二维码。可选，不安装时会请求 jiathis Api 生成二维码。</p><pre><code class="bash">$ npm install hexo-helper-qrcode --save</code></pre><h3 id="开启标签页"><a href="#开启标签页" class="headerlink" title="开启标签页"></a>开启标签页</h3><pre><code class="bash">$ hexo new page tags  INFO  Created: ~/dev/blog/source/tags/index.md</code></pre><p>修改 <code>blog/source/tags/index.md</code> 的元数据</p><pre><code class="markdown">---title: tagsdate: 2017-06-18 18:35:37layout: tagscomments: false---</code></pre><h3 id="开启分类页"><a href="#开启分类页" class="headerlink" title="开启分类页"></a>开启分类页</h3><pre><code class="bash"># 仅 card theme 支持$ hexo new page categories  INFO  Created: ~/dev/blog/source/categories/index.md</code></pre><p>修改 <code>blog/source/categories/index.md</code> 的元数据</p><pre><code class="markdown">---title: categoriesdate: 2017-06-18 18:41:23layout: categoriescomments: false---</code></pre><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">hexo-theme-indigo</a></p><h2 id="备份-blog-源码"><a href="#备份-blog-源码" class="headerlink" title="备份 blog 源码"></a>备份 blog 源码</h2><p><a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="noopener">hexo-git-backup</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/cmf/Desktop/essay/img/Jietu20180312-221423.jpg" alt="Jietu20180312-221423" title="">                </div>                <div class="image-caption">Jietu20180312-221423</div>            </figure><pre><code class="bash">$ ssh -T git@gitee.com  Welcome to Gitee.com, CMF!</code></pre><p>安装 hexo-git-backup</p><pre><code class="bash"># 如果 hexo 版本号是 2.x.x$ npm install hexo-git-backup@0.0.91 --save# 如果 hexo 版本号是 3.x.x$ npm install hexo-git-backup --save</code></pre><p>配置 blog/_config.yml</p><pre><code class="yaml">backup:  type: git  # 备份主题  ## theme: your theme name,your theme name  ## theme/your theme name/.git 将会被移除  theme: indigo,landscape  # 提交信息  message: update  # 仓库  repository:    github: git@github.com:xxx/xxx.git,branchName    gitcafe: git@gitcafe.com:xxx/xxx.git,branchName    gitee: git@gitee.com:xxx/xxx.git,branchName</code></pre><p>使用，如有权限问题，使用 sudo</p><pre><code class="bash">$ hexo backup# 或者$ hexo b</code></pre><h2 id="克隆-blog-源码"><a href="#克隆-blog-源码" class="headerlink" title="克隆 blog 源码"></a>克隆 blog 源码</h2><p>具备 Git、Node、Hexo 等环境后，执行以下命令。</p><pre><code class="bash">$ git clone git@gitee.com:xxx/xxx.git blog$ cd blog$ npm install$ hexo server</code></pre><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>新建文本文档，复制粘贴以下代码，Mac 系统保存为 <code>.sh</code> 文件，Win 系统保存为 <code>.bat</code> 文件。</p><pre><code class="bash"># 进入 blog 所在目录cd /Users/cmf/dev/blog# 清除缓存文件 (db.json) 和已生成的静态文件 (public)# 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令# 一般情况不执行# hexo clean# 生成静态文件，简写：hexo ghexo generate# 部署网站，简写：hexo dhexo deploy# 备份源码，简写：hexo bhexo backup</code></pre><p>修改权限：</p><pre><code class="bash"># 进入 file_name.sh 目录$ chmod +x file_name.sh</code></pre><h2 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h2><pre><code class="bash"># 初始化$ hexo init# 清空静态页面$ hexo clean# 生成静态页面$ hexo generate$ hexo g# 本地测试$ hexo server$ hexo s# 部署$ hexo deploy$ hexo d# 新建文章$ hexo new &quot;postName&quot;# 新建页面$ hexo new page &quot;pageName&quot;# 查看帮助$ hexo help</code></pre><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><h3 id="不渲染指定文件或目录"><a href="#不渲染指定文件或目录" class="headerlink" title="不渲染指定文件或目录"></a>不渲染指定文件或目录</h3><p>如果要把平时写的一些 demo 也放到博客上去，可以放到 Hexo 工程中的 source 目录下。但默认情况下，Hexo 会把里面的文件进行处理，导致这些页面都渲染上了博客主题。</p><p>要是我们将这些 demo 都放到 demos 目录下，要忽略 demos 目录下的所有 html 文件，可以通过在 <code>_config.yml</code> 设置 skip_render</p><pre><code class="yaml">skip_render: &#39;demos/*.html&#39;</code></pre><p>文件匹配是基于正则匹配，更复杂的情况如下：</p><pre><code></code></pre><p>Hexo 工程中 source 目录下的文件在生成静态页面时，会被渲染主题的样式</p><p>Hexo 只渲染 source 目录下的文件。skip_render 参数设置的路径是相对于 source 目录的路径。</p><p>假设 source 下的目录树：</p><pre><code class="txt">.├── _posts│   ├── blog-base-on-hexo-and-github.md│   ├── usage-git.md│   └── usage-node.md├── categories│   └── index.md├── demos│   └── index.md├── plugins│   └── highlight│       ├── atom-one-dark.css│       ├── highlight.pack.js│       └── monokai-sublime.css├── tags|    └── index.md├── 404.html└── CNAME</code></pre><pre><code class="yaml"># 排除单个文件夹下指定类型的文件skip_render: &#39;folder/*.md&#39;# 排除单个文件夹下全部类型的文件skip_render: &#39;folder/*&#39;# 排除单个文件夹下全部类型的文件以及子目录skip_render: &#39;folder/**&#39;# 排除多个文件夹下文件的复杂情况skip_render:    - &#39;README.md&#39;    - &#39;folder1/*.md&#39;    - &#39;folder2/**&#39;# 排除单个文件skip_render: &#39;404.html&#39;skip_render: &#39;demos/index.md&#39;# 排除多个文件，简写：skip_render: &#39;plugins/highlight/*.css&#39;skip_render:    - &#39;plugins/highlight/atom-one-dark.css&#39;    - &#39;plugins/highlight/monokai-sublime.css&#39;# 排除 plugins/highlight 目录下所有文件skip_render: &#39;plugins/highlight/**&#39;</code></pre><p>还有另一种方法</p><p>在不想被渲染的 html 文件最上面添加以下代码：</p><pre><code class="html">---layout: false---</code></pre><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>GitHub 中有篇文章介绍如何绑定域名：<a href="https://help.github.com/articles/about-supported-custom-domains/" target="_blank" rel="noopener">About supported custom domains</a></p><p>在 <code>blog/source</code> 目录下，新建命名为 <code>CNAME</code> 的文件，里面内容为需要绑定的域名，不包含 http、www 等前缀。如：</p><pre><code class="txt">cmflife.com</code></pre><blockquote></blockquote><p>在终端使用 <code>ping</code> 指令查看 username.github.io 对应的 ip 地址</p><pre><code class="bash">$ ping username.github.io</code></pre><p>前往购买域名的平台进行 IPv4 域名解析，输入 <code>ping</code> 到的 ip 地址即可。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 无反应？</strong></p><p>一般是端口占用的原因。使用 <code>Ctrl+C</code> 中断本地服务，执行命令 <code>hexo s -p 5000</code> 更改端口号并重新开启本地服务，访问 <a href="http://localhost:5000/" target="_blank" rel="noopener">http://localhost:5000/</a> 即可。</p><p><strong>对项目中的部分文件进行修改后，预览时并没有生效？</strong></p><p>针对修改后没有生效的情况，一般是对配置文件进行了修改，需要 <code>hexo clean</code> 后才能生效。</p><p><strong>hexo deploy 没反应？</strong></p><p>修改配置文件：_config.yml 时，冒号后面没加空格。</p><p><strong>hexo backup 出错？</strong></p><pre><code class="bash">$ hexo backup  Please make sure you have the correct access rights and the repository exists.  ERROR: Repository not found.  fatal: Could not read from remote repository.</code></pre><p><code>.git</code> 中已经配置了远程仓库，导致更换仓库地址后出现这个问题，删掉 blog 目录中的 <code>.git</code> 文件夹，重新执行 <code>hexo backup</code> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态
      
    
    </summary>
    
      <category term="Web" scheme="https://mingfengst.github.io/categories/Web/"/>
    
    
      <category term="Blog" scheme="https://mingfengst.github.io/tags/Blog/"/>
    
      <category term="Hexo" scheme="https://mingfengst.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://mingfengst.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Node 的用法</title>
    <link href="https://mingfengst.github.io/posts/2014/usage-node/"/>
    <id>https://mingfengst.github.io/posts/2014/usage-node/</id>
    <published>2014-06-18T06:22:46.000Z</published>
    <updated>2018-04-07T15:19:06.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-安装"><a href="#Node-安装" class="headerlink" title="Node 安装"></a>Node 安装</h2><p>到 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node 官网</a> 获取安装包。</p><blockquote><p>注意：从官方链接下载安装包可能需要翻墙！</p></blockquote><p>安装过程建议保持默认设置，一路 next！但出于操作方便考虑，可以将 PATH 选项按照下图选择：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/cmf/Desktop/essay/img/Jietu20170620-151437.jpg" alt="Jietu20170620-151437" title="">                </div>                <div class="image-caption">Jietu20170620-151437</div>            </figure><blockquote><p>Git 的默认设置下，出于安全考虑，只有在 Git Bash 中才能进行 Git 的相关操作。按照上图的选择，将会使得 Git 安装程序在系统 PATH 中加入 Git 的相关路径，这样就可以在 CMD 界面下调用 Git，不用打开 Git Bash。</p></blockquote><p>检查是否安装成功，能获取到对应版本号，则说明安装成功。</p><pre><code class="bash">$ node -v$ npm -v</code></pre><p>安装 cnpm，如有权限问题，使用 sudo 安装。</p><pre><code class="bash">$ sudo npm install -g cnpm</code></pre><h2 id="设置-npm-淘宝镜像"><a href="#设置-npm-淘宝镜像" class="headerlink" title="设置 npm 淘宝镜像"></a>设置 npm 淘宝镜像</h2><p>npm 默认源的下载速度可能很慢，建议替换成淘宝镜像。</p><pre><code class="bash">$ npm config set registry &quot;https://registry.npm.taobao.org&quot;</code></pre><h2 id="Node-常用命令"><a href="#Node-常用命令" class="headerlink" title="Node 常用命令"></a>Node 常用命令</h2><pre><code class="bash"># 查看 node 的版本号$ node -v# 查看 npm 的版本号$ npm -v</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Node-安装&quot;&gt;&lt;a href=&quot;#Node-安装&quot; class=&quot;headerlink&quot; title=&quot;Node 安装&quot;&gt;&lt;/a&gt;Node 安装&lt;/h2&gt;&lt;p&gt;到 &lt;a href=&quot;https://nodejs.org/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="工具" scheme="https://mingfengst.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发环境" scheme="https://mingfengst.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
      <category term="Node" scheme="https://mingfengst.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Git 的用法</title>
    <link href="https://mingfengst.github.io/posts/2014/usage-git/"/>
    <id>https://mingfengst.github.io/posts/2014/usage-git/</id>
    <published>2014-06-18T05:32:05.000Z</published>
    <updated>2018-04-25T09:17:52.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><p>到 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git 官网</a> 获取安装包。</p><blockquote><p>注意：从官方链接下载安装包可能需要翻墙！</p></blockquote><p>安装过程建议保持默认设置，一路 next！</p><p>检查是否安装成功，能获取到对应版本号，则说明安装成功。</p><pre><code class="bash">$ git --version</code></pre><h2 id="注册-GitHub"><a href="#注册-GitHub" class="headerlink" title="注册 GitHub"></a>注册 GitHub</h2><p>进入 <a href="https://github.com/" target="_blank" rel="noopener">GitHub 官网</a>，已经有 GitHub 账号的可以直接 <a href="https://github.com/login" target="_blank" rel="noopener">登录</a>，还没有的需要 <a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">注册</a>，根据提示输入用户名、Email、密码即可完成注册。</p><blockquote><p>注意：GitHub 账号用户名一旦注册成功就不能修改。比如我的用户名是 mingfengst。</p></blockquote><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h3><p>在终端设置 user.name 和 user.email。</p><pre><code class="bash">$ git config --global user.name &quot;your_github_user.name&quot;$ git config --global user.email &quot;your_github_user.email&quot;</code></pre><p>生成 ssh 密钥。</p><pre><code class="bash">$ ssh-keygen -t rsa -C &quot;your_github_user.email&quot;  # 设置保存的路径，密码（可直接回车跳过）  Generating public/private rsa key pair.  Enter file in which to save the key (/Users/cmf/.ssh/id_rsa):  Created directory &#39;/Users/cmf/.ssh&#39;.  Enter passphrase (empty for no passphrase):  Enter same passphrase again:  Your identification has been saved in /Users/cmf/.ssh/id_rsa.  Your public key has been saved in /Users/cmf/.ssh/id_rsa.pub.  The key fingerprint is:  SHA256:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX your_github_user.email  The key&#39;s randomart image is:  +---[RSA 2048]----+  |  .. ..        .X|  | o  ..   .      .|  |  o   . = o . .o |  |   .   X X + +  o|  |  .   . X O . o .|  | . . . . X o . + |  |  + + o o . . o  |  |  o*.=.  .       |  | ..=*...         |  +----[SHA256]-----+</code></pre><blockquote><p>此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的 ssh 密钥文件 id_rsa 和 id_rsa.pub。</p></blockquote><h3 id="添加-SSH-到-GitHub"><a href="#添加-SSH-到-GitHub" class="headerlink" title="添加 SSH 到 GitHub"></a>添加 SSH 到 GitHub</h3><p>用户头像 → Settings → SSH and GPG keys → New SSH key → 将 id_rsa.pub 中的内容复制到 Key 文本框中，然后点击 Add SSH key（添加 SSH）按钮。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/cmf/Desktop/essay/img/Jietu20180301-230037.jpg" alt="Jietu20180301-230037" title="">                </div>                <div class="image-caption">Jietu20180301-230037</div>            </figure><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><pre><code class="bash"># 查看 git 的版本号$ git --version# 查看 git 的安装路径（Mac）$ which git# 查看 git 的安装路径（Win）$ where git# 克隆仓库，默认与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为第二个参数$ git clone &lt;版本库地址&gt; &lt;本地目录名&gt;# 查看远程库地址$ git remote -v# 查看分支，* 为当前分支$ git branch# 新建分支$ git branch &lt;分支名&gt;# 切换分支$ git checkout &lt;分支名&gt;# 新建并切换到新分支$ git checkout -b &lt;分支名&gt;# 删除分支（两者有区别）$ git branch -d &lt;branch_name&gt;$ git branch -D &lt;branch_name&gt;# 恢复被删除的分支$ git branch &lt;branch_name&gt; &lt;hash_val&gt;# 回退到指定版本，保留当前源码的更改$ git reset &lt;commit_id&gt;# 回退到指定版本，放弃当前源码的更改（添加了参数 --hard）$ git reset --hard &lt;commit_id&gt;# 回退到上 n 个版本$ git reset HEAD~n$ git reset --hard HEAD~n# 使用 reset 方法进行回退后，推送的时候需要添加参数 --force$ git push --force# 版本回退，不会擦除“回退”之后的 commit_id，而是正常的当做一次 commit，产生一次新的操作记录，所以可以 push，不会让你再 pull$ git revert &lt;commit_id&gt;# 查看命令历史记录（可查看到被删除的 commit 记录）$ git reflog# 查看提交历史记录$ git log# 添加更改到缓冲区$ git add .# 提交$ git commit -m &#39;提交备注&#39;# 推送到远程库$ git push origin &lt;分支名&gt;# $ git update-ref -d HEAD</code></pre><h2 id="删除-git-版本库中的-commit"><a href="#删除-git-版本库中的-commit" class="headerlink" title="删除 git 版本库中的 commit"></a>删除 git 版本库中的 commit</h2><pre><code class="bash"># 方案 1$ git reset &lt;commit_id&gt;           # 回退到指定版本，保留当前源码的更改$ git reset --hard &lt;commit_id&gt;    # 回退到指定版本，放弃当前源码的更改$ git reset HEAD~n                # 回退到上 n 个版本$ git reset --hard HEAD~n$ git push --force                # 使用 reset 方法进行回退后，推送的时候需要添加参数 --force# 方案 2$ git revert &lt;commit_id&gt;</code></pre><p>假设一开始 git 仓库本地和远程都是 <code>a -&gt; b -&gt; c</code>，想把 HEAD 回退到 b，那么在本地就变成了 <code>a -&gt; b</code>，这时，如果没有远程库，那么接下来怎么操作都可以，比如 <code>a -&gt; b -&gt; d</code>，但是在有远程库的情况下，<code>git push</code> 会失败，因为远程库是 <code>a -&gt; b -&gt; c</code>，本地库是 <code>a -&gt; b -&gt; d</code>，以下是两种解决方案：</p><ol><li><code>git push</code> 的时候用 <code>--force</code> 参数，强制把远程库变成 <code>a -&gt; b -&gt; d</code>，但是在大部分公司里是不允许这么做的。</li><li>使用 <code>git revert &lt;commit_id&gt;</code> 做一个反向操作，实现以退为进，把本地变成 <code>a -&gt; b -&gt; c -&gt; d</code>，注意 b 和 d 文件快照内容一模一样，但是 commit_id 肯定不同，再 push 到远程也会变成 <code>a -&gt; b -&gt; c -&gt; d</code>。</li></ol><p><code>git revert</code> 不同于 <code>git reset</code>，它不会擦除 “回退” 之后的 commit_id，而是正常的当做一次 commit，产生一次新的操作记录，所以可以 push，不会让你再 pull。</p><h2 id="合并-git-版本库"><a href="#合并-git-版本库" class="headerlink" title="合并 git 版本库"></a>合并 git 版本库</h2><p>有 2 个 git 仓库：A 和 B，想要把这两个仓库进行合并，并且要保留之前的 commit 记录，也就是说要把 A 仓库中的文件移动到 B 仓库中，并且 A 仓库之前的 commit 记录也要在 B 仓库中保留。</p><p>A 仓库的目录树：</p><pre><code class="txt">A├── .git├── 01-demo.js└── README.md</code></pre><p>B 仓库的目录树：</p><pre><code class="txt">B├── .git├── 02-demo.js└── README.md</code></pre><p>合并仓库后的目录树：</p><pre><code class="txt">.├── .git├── 01-demo.js├── 02-demo.js└── README.md</code></pre><p>第一步：进入 B 仓库的目录，将 A 作为远程仓库，添加到 B 仓库中，并设置别名为 other。</p><pre><code class="bash">[B] $ git remote add other ../A    # ../A 为 A 仓库的路径</code></pre><p>第二步：从 A 仓库中抓取数据到 B 仓库。</p><pre><code class="bash">[B] $ git fetch other# remote: Counting objects: 3, done.# remote: Compressing objects: 100% (3/3), done.# remote: Total 3 (delta 0), reused 0 (delta 0)# Unpacking objects: 100% (3/3), done.# From ../A#  * [new branch]      master     -&gt; other/master</code></pre><p>第三步：将 A 仓库中抓取的 master 分支作为新分支 checkout 到 B 仓库，并设置新分支名为 A_branch。</p><pre><code class="bash">[B] $ git checkout -b A_branch other/master# Branch &#39;A_branch&#39; set up to track remote branch &#39;master&#39; from &#39;other&#39;.# Switched to a new branch &#39;A_branch&#39;</code></pre><p>第四步：完成上一步后，当前分支是 A_branch，切换回 B 仓库的 master 分支。</p><pre><code class="bash">[B] $ git checkout master# Switched to branch &#39;master&#39;</code></pre><p>第五步：将 A_branch 分支合并入 B 仓库的 master 分支。</p><pre><code class="bash">[B] $ git merge A_branch# fatal: refusing to merge unrelated histories</code></pre><p>如果出现以上错误，在命令后添加 <code>--allow-unrelated-histories</code> 即可。</p><pre><code class="bash">[B] $ git merge A_branch --allow-unrelated-histories# 合并时出现冲突的情况：# Auto-merging README.md# CONFLICT (add/add): Merge conflict in README.md# Automatic merge failed; fix conflicts and then commit the result.# 合并成功的情况：# Merge made by the &#39;recursive&#39; strategy.</code></pre><p>如果合并时发生冲突，那么需要先解决冲突后，再 commit 文件。</p><pre><code class="bash">$ git add .$ git commit -m &#39;Update&#39;</code></pre><p>之后 <code>git log --pretty=oneline</code> 可以看到两个合并后的仓库的 commit 也保留了下来。</p><h2 id="拆分-git-版本库"><a href="#拆分-git-版本库" class="headerlink" title="拆分 git 版本库"></a>拆分 git 版本库</h2><p>现有一个名为 Case 的 git 仓库，里面包含了多个项目或者模块的文件夹，现在要把每个文件夹独立出来作为一个 git 仓库，并且保留之前各自提交的 commit 记录。</p><p>要拆分的 git 仓库目录树：</p><pre><code class="txt">.├── .git├── other├── vue-musicPlayer└── weapp-QQmusicPlayer</code></pre><p>以拆分 vue-musicPlayer 文件夹为例：</p><p>第一步：进入 Case 目录，将 Case 仓库中关于 vue-musicPlayer 的提交信息抽取出来作为新的分支。</p><pre><code class="bash">[Case] $ git subtree split -P &lt;folder_name&gt; -b &lt;branch_name&gt;# eg: git subtree split -P vue-musicPlayer -b vue-musicPlayer# Created branch &#39;vue-musicPlayer&#39;</code></pre><p>第二步：新建 vue-musicPlayer 仓库，并从 Case 仓库中拉取 vue-musicPlayer 分支的内容，即可成为独立的仓库。</p><pre><code class="bash">[Case] $ cd ..[~] $ mkdir vue-musicPlayer[~] $ cd vue-musicPlayer[vue-musicPlayer] $ git init[vue-musicPlayer] $ git pull ../Case vue-musicPlayer# remote: Counting objects: 30, done.# remote: Compressing objects: 100% (26/26), done.# remote: Total 30 (delta 0), reused 27 (delta 0)# Unpacking objects: 100% (30/30), done.# From ../Case#  * branch            vue-musicPlayer -&gt; FETCH_HEAD</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-安装&quot;&gt;&lt;a href=&quot;#Git-安装&quot; class=&quot;headerlink&quot; title=&quot;Git 安装&quot;&gt;&lt;/a&gt;Git 安装&lt;/h2&gt;&lt;p&gt;到 &lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="https://mingfengst.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发环境" scheme="https://mingfengst.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
      <category term="Git" scheme="https://mingfengst.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mingfengst.github.io/posts/2014/hello-world/"/>
    <id>https://mingfengst.github.io/posts/2014/hello-world/</id>
    <published>2014-06-18T05:14:20.000Z</published>
    <updated>2017-06-18T12:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
